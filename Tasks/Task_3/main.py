# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'First.ui'
#
# Created by: PyQt5 UI code generator 5.15.6
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from email.mime import image
from PyQt5 import QtCore, QtGui, QtWidgets
from PyQt5.QtGui import QPixmap, QImage
import numpy as np
from numpy.linalg import inv
import matplotlib as plt
from PIL import Image
import math

class Ui_Rotation_Shearing(object):
    def setupUi(self, Rotation_Shearing):
        Rotation_Shearing.setObjectName("Rotation_Shearing")
        Rotation_Shearing.setEnabled(True)
        Rotation_Shearing.resize(839, 457)
        self.nearestWidget = QtWidgets.QLabel(Rotation_Shearing)
        self.nearestWidget.setGeometry(QtCore.QRect(40, 30, 160, 160))
        self.nearestWidget.setFrameShape(QtWidgets.QFrame.WinPanel)
        self.nearestWidget.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.nearestWidget.setText("")
        self.nearestWidget.setObjectName("nearestWidget")
        self.layoutWidget = QtWidgets.QWidget(Rotation_Shearing)
        self.layoutWidget.setGeometry(QtCore.QRect(50, 370, 522, 30))
        self.layoutWidget.setObjectName("layoutWidget")
        self.horizontalLayout = QtWidgets.QHBoxLayout(self.layoutWidget)
        self.horizontalLayout.setContentsMargins(0, 0, 0, 0)
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.lineEditAngle = QtWidgets.QLineEdit(self.layoutWidget)
        self.lineEditAngle.setEnabled(True)
        self.lineEditAngle.setObjectName("lineEditAngle")
        self.horizontalLayout.addWidget(self.lineEditAngle)
        self.labelDirection = QtWidgets.QLabel(self.layoutWidget)
        self.labelDirection.setEnabled(True)
        self.labelDirection.setObjectName("labelDirection")
        self.horizontalLayout.addWidget(self.labelDirection)
        self.pushButtonNearest = QtWidgets.QPushButton(self.layoutWidget)
        self.pushButtonNearest.setObjectName("pushButtonNearest")
        self.horizontalLayout.addWidget(self.pushButtonNearest)
        self.pushButtonBilinear = QtWidgets.QPushButton(self.layoutWidget)
        self.pushButtonBilinear.setObjectName("pushButtonBilinear")
        self.horizontalLayout.addWidget(self.pushButtonBilinear)
        self.pushButtonApply = QtWidgets.QPushButton(self.layoutWidget)
        self.pushButtonApply.setEnabled(True)
        self.pushButtonApply.setObjectName("pushButtonApply")
        self.horizontalLayout.addWidget(self.pushButtonApply)
        self.bilinearWidget = QtWidgets.QLabel(Rotation_Shearing)
        self.bilinearWidget.setGeometry(QtCore.QRect(290, 30, 160, 160))
        self.bilinearWidget.setFrameShape(QtWidgets.QFrame.WinPanel)
        self.bilinearWidget.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.bilinearWidget.setText("")
        self.bilinearWidget.setObjectName("bilinearWidget")
        self.shearingWidget = QtWidgets.QLabel(Rotation_Shearing)
        self.shearingWidget.setGeometry(QtCore.QRect(550, 30, 300, 221))
        self.shearingWidget.setFrameShape(QtWidgets.QFrame.WinPanel)
        self.shearingWidget.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.shearingWidget.setText("")
        self.shearingWidget.setObjectName("shearingWidget")

        self.retranslateUi(Rotation_Shearing)
        QtCore.QMetaObject.connectSlotsByName(Rotation_Shearing)
        self.pictureArrays()
        self.pushButtonApply.clicked.connect(self.rhombize)
        self.pushButtonNearest.clicked.connect(self.nearestNeighbourRotate)
        self.pushButtonBilinear.clicked.connect(self.rotateby_bilinear)
        
    def pictureArrays(self):
        self.whiteArray = np.zeros([128, 128], dtype=np.uint8)
        # Set grey value to black or white depending on x position
        for x in range(29,100):
            for y in range(29,50):
                self.whiteArray[y, x] = 255
        for x in range(53,74):
            for y in range(50,100):
                self.whiteArray[y, x] = 255
        #print(self.whiteArray)
        self.whiteImg = Image.fromarray(self.whiteArray)
        self.whiteImg = self.whiteImg.convert("L")
        self.whiteImg = self.whiteImg.toqpixmap()
        self.nearestWidget.setPixmap(self.whiteImg)
        self.bilinearWidget.setPixmap(self.whiteImg)
    
    def nearestNeighbourRotate(self):
        '''
        This function rotates the image around its center by amount of degrees
        provided. The rotated image will show the full image.
        '''
        # First we will convert the degrees into radians
        self.nearestWidget.clear()
        self.degrees = int(self.lineEditAngle.text())
        data = self.whiteArray
        self.rads = math.radians(self.degrees)
        # Finding the center point of the original image
        cx, cy = (data.shape[1] // 2, data.shape[0] // 2)
        height_rot_img = round(abs(data.shape[0] * math.sin(self.rads))) + \
                         round(abs(data.shape[1] * math.cos(self.rads)))
        width_rot_img = round(abs(data.shape[1] * math.cos(self.rads))) + \
                        round(abs(data.shape[0] * math.sin(self.rads)))
        rot_img = np.uint8(np.zeros((height_rot_img, width_rot_img)))
        # Finding the center point of rotated image.
        midx, midy = (width_rot_img // 2, height_rot_img // 2)

        for i in range(rot_img.shape[0]):
            for j in range(rot_img.shape[1]):
                x = (i - midx) * math.cos(self.rads) + (j - midy) * math.sin(self.rads)
                y = -(i - midx) * math.sin(self.rads) + (j - midy) * math.cos(self.rads)
                if (i > data.shape[0] - 1 or j > data.shape[1] - 1):
                    x = int(x) + cy
                    y = int(y) + cx
                else:
                    x = round(x) + cy
                    y = round(y) + cx
                if (x >= 0 and y >= 0 and x < data.shape[0] and y < data.shape[1]):
                    rot_img[i, j] = data[x, y]

        self.rot_img = Image.fromarray((rot_img).astype(np.uint8)).convert('L')  # converting array to image
        
        scaled_image = np.uint8(self.rot_img)
        self.finalImage = Image.fromarray(scaled_image) #Displaying The Image
        self.finalImage = self.finalImage.convert("L")
        self.rotatedImg = self.finalImage.toqpixmap()
        self.nearestWidget.setPixmap(self.rotatedImg)
    
    def rotateby_bilinear(self):

        dataBi = self.whiteArray
        
        # Finding the center point of the original image
        cx, cy = (dataBi.shape[1] // 2, dataBi.shape[0] // 2)
        self.rotated_img = np.uint8(np.zeros(dataBi.shape))
        self.degrees = int(self.lineEditAngle.text())
        self.rads = math.radians(self.degrees)
        #self.rot_img=np.zeros(128,128,3)

        for i in range(self.rotated_img.shape[0]):
            for j in range(self.rotated_img.shape[1]):
                x = (i - cx) * math.cos(self.rads) + (j - cy) * math.sin(self.rads)
                y = -(i - cx) * math.sin(self.rads) + (j - cy) * math.cos(self.rads)
                x = (x) + cx
                y = (y) + cy

                if (x >= 0 and y >= 0 and x < dataBi.shape[0] and y < dataBi.shape[1]):
                    x_floor = math.floor(x)
                    x_ceil = min(128 - 1, math.ceil(x))
                    y_floor = math.floor(y)
                    y_ceil = min(128 - 1, math.ceil(y))
                    if ((x_ceil >= 0) and (y_ceil >= 0) and (x_floor >= 0) and (y_floor >= 0) and (x_ceil < dataBi.shape[0]) and (y_ceil < dataBi.shape[1]) and (x_floor < dataBi.shape[0]) and (y_floor < dataBi.shape[1])):
                        if (x_ceil == x_floor) and (y_ceil == y_floor):
                            q = self.whiteArray[int(x), int(y)]
                        elif (x_ceil == x_floor):
                            q1 = self.whiteArray[int(x), int(y_floor)]
                            q2 = self.whiteArray[int(x), int(y_ceil)]
                            q = q1 * (y_ceil - y) + q2 * (y - y_floor)
                        elif (y_ceil == y_floor):
                            q1 = self.whiteArray[int(x_floor), int(y)]
                            q2 = self.whiteArray[int(x_ceil), int(y)]
                            q = (q1 * (x_ceil - x)) + (q2 * (x - x_floor))
                        else:
                            v1 = self.whiteArray[x_floor, y_floor]
                            v2 = self.whiteArray[x_ceil, y_floor]
                            v3 = self.whiteArray[x_floor, y_ceil]
                            v4 = self.whiteArray[x_ceil, y_ceil]

                            q1 = v1 * (x_ceil - x) + v2 * (x - x_floor)
                            q2 = v3 * (x_ceil - x) + v4 * (x - x_floor)
                            q = q1 * (y_ceil - y) + q2 * (y - y_floor)

                        self.rotated_img[i, j] = q
                    #  self.rot_img[i, j] = data[x, y]

        # converting array to image
        image = Image.fromarray((self.rotated_img).astype(np.uint8)).convert('L')
        image = image.toqpixmap()
        self.bilinearWidget.setPixmap(image)
        
    def rhombize(self):
        self.whiteImg = Image.fromarray(self.whiteArray)
        w0, h0 = self.whiteImg.size
        angles = np.radians((-45, 0))
        tanx, tany = np.tan(angles)
        cosx, cosy = np.cos(angles)

        '''
        Transform the old image coordinates to the new image coordinates
        [ a b c ][ x ]   [ x']
        [ d e f ][ y ] = [ y']
        [ 0 0 1 ][ 1 ]   [ 1 ]
        '''
        shear = np.array((
            # x col    y col      global col
            (1/cosx,   tanx, max(0, -h0*tanx)),  # -> x' row
            (  tany, 1/cosy, max(0, -w0*tany)),  # -> y' row
            (     0,      0,                1),  # -> 1  row
        ))
        #print(shear.shape)

        size_transform = np.abs(shear[:2, :2])
        w1, h1 = (size_transform @ self.whiteImg.size).astype(int)  # @ operator for dot product between matrix 
        #print(w1,h1,size_transform)

        #print(shear)
        '''
        The original implementation was assigning old coordinates to new 
        coordinates on the left-hand side, so this needs to be inverted
        '''
        shear = inv(shear)     # Without inverse for the matrix, shearing is anticlockwise and shifted to the left side of the image
        #print(shear)

        self.rhombised = self.whiteImg.transform(         # Transform to create an image with the new size
            size=(w1, h1),
            method=Image.AFFINE,           # Affine for mapping the pixels to the new matrix
            data=shear[:2, :].flatten(),   # Flatten to return a 1-D array in row style and use the data returned to fill the new matrix
            # resample omitted - we don't really care about quality
        )
        #print(shear[:2, :].flatten())
        #self.rhombised = self.whiteImg.convert("L")
        self.rhombised = self.rhombised.toqpixmap()
        self.shearingWidget.setPixmap(self.rhombised)
    
    def retranslateUi(self, Rotation_Shearing):
        _translate = QtCore.QCoreApplication.translate
        Rotation_Shearing.setWindowTitle(_translate("Rotation_Shearing", "GroupBox"))
        self.labelDirection.setText(_translate("Rotation_Shearing", "Direction"))
        self.pushButtonNearest.setText(_translate("Rotation_Shearing", "Apply Nearest"))
        self.pushButtonBilinear.setText(_translate("Rotation_Shearing", "Apply Bilinear"))
        self.pushButtonApply.setText(_translate("Rotation_Shearing", "Apply Shearing"))


if __name__ == "__main__":
    import sys
    app = QtWidgets.QApplication(sys.argv)
    Rotation_Shearing = QtWidgets.QGroupBox()
    ui = Ui_Rotation_Shearing()
    ui.setupUi(Rotation_Shearing)
    Rotation_Shearing.show()
    sys.exit(app.exec_())
